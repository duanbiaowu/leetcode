package leetcode

func finalPrices(prices []int) []int {
	n := len(prices)
	res := make([]int, n)

	// 1. 初始化单调栈
	// 因为只需要计算折扣后的值
	// 所以栈内存储数组值就可以
	// 栈顶始终保留一个值 0 作为 “哨兵”
	// 避免边界检查，同时表示语义: “没有折扣”
	stack := []int{0}

	// 2. 遍历数组
	// 题目声明，享受折扣时的索引必须比当前索引大
	// 也就是说，数组中的最后一件商品价格无法享受任何优惠
	// 所以直接从数组倒数第二件商品开始，从后向前遍历即可
	for i := n - 1; i >= 0; i-- {
		// 当前栈内的商品价格依次递增，符合单调递增的特性
		// 也就是说，如果一个商品价格出现在栈内
		// 说明还未找到 该商品价格 对应的 折扣价格

		// 3. 维护单调递增性
		// 如果 栈顶商品价格 比 当前商品价格 大，说明当前单调递增性已经被破坏
		// 那么此时就可以开始给当前商品 寻找对应的 折扣价格 了
		// 弹出栈顶商品价格，直到遇到比 当前商品价格 小的 商品价格(折扣价格)
		for len(stack) > 1 && stack[len(stack)-1] > prices[i] {
			stack = stack[:len(stack)-1]
		}

		// 4. 处理具体逻辑

		// 此时 栈顶商品价格 就是 当前商品价格 可以享受的折扣
		// 更新即可
		res[i] = prices[i] - stack[len(stack)-1]

		// 将当前商品价格入栈
		stack = append(stack, prices[i])
	}

	return res
}
